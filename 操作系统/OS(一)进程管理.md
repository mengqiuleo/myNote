

# 操作系统学习笔记(一)进程管理

[TOC]



## 一、进程与线程

### 1.进程的概念与特征

#### 进程的概念

从不同的角度，进程可以有不同的定义，比较典型的有：

- 进程是程序的一次执行过程
- 进程是一个程序及其数据在处理机上顺序执行时所发生的的活动
- 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配合调度的一个独立单位

> 进程是进程实体的运行过程，是系统进行资源分配个调度的一个独立单位



系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。

由程序段、相关数据段和PCB三部分构成了进程映像（进程实体）。

- 创建进程，就是创建进程映像中的PCB；
- 撤销进程，就是撤销进程中的PCB

进程映像是静态的，进程是动态的。

![](E:\note\OS\进程\组成.jpg)



#### 进程的特征

![](E:\note\OS\进程\特征.jpg)



### 2.进程的状态与转换

#### 五种状态

![](E:\note\OS\进程\状态.jpg)

![](E:\note\OS\进程\状态2.jpg)



#### 状态转换

![](E:\note\OS\进程\状态转换.jpg)



#### 总结

![](E:\note\OS\进程\总结.jpg)



### 3.进程控制

> 进程控制就是要实现进程状态转换
>
> 用**原语**实现进程控制

相关原语：

- 进程的创建
- 进程的终止
- 进程的阻塞
- 进程的唤醒
- 进程的切换

进程的阻塞与进程的唤醒要成对出现

![](E:\note\OS\进程\创建.jpg)

![](E:\note\OS\进程\终止.jpg)

![](E:\note\OS\进程\阻塞与唤醒.jpg)

![](E:\note\OS\进程\切换.jpg)

#### 总结

![](E:\note\OS\进程\总结2.jpg)



### 4.进程通信

#### 共享存储

- 基于数据结构的共享
- 基于存储区的共享

在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。

两个进程对共享空间的**访问**必须是**互斥**的（互斥访问通过操作系统提供的工具实现：操作系统只负责提供共享空间
和同步互斥工具（如P、V操作））。

共享存储分为两种：

- 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、
  限制多，是一种低级通信方式

- 基于存储区的共享：在内存中画出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。相比之下，这种共享方式速度更快，是一种高级通信方式。

![](E:\note\OS\进程\共享存储.jpg)

#### 管道通信

“管道”是指用于连接读写进程的一个共享文件，又名pipe文件。其实就是在内存中开辟一个大小固定的缓冲区。

![](E:\note\OS\进程\管道通信.jpg)



1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。
2. 各进程要互斥地访问管道。
3. 数据以字符流的形式写入管道，当管道写满时，写进程的write()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4. 如果没写满，就不允许读。如果没读空，就不允许写。
5. 数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情况。



#### 消息传递

进程间的数据交换以格式化的消息（Message）为单位。进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。

一个消息：

![](E:\note\OS\进程\消息.jpg)

消息传递分为两种：

- 直接通信方式：消息直接挂到接收进程的消息缓冲队列上
- 间接通信方式：消息要先发送到中间实体（信箱）中，因此也称“信箱通信方式”。Eg: 计网中的电子邮件系统



##### 直接通信方式🌰：

![](E:\note\OS\进程\直接通信.jpg)



##### 间接通信方式🌰：

![](E:\note\OS\进程\简介通信.jpg)



### 5.线程与多线程模型

线程最直接的理解就是“轻量级进程”，线程是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，线程可与同属于一个进程的多个线程共享进程所拥有的资源。

#### 一个🌰

类比：

- 切换进程运行环境：有一个不认识的人要用桌子，你需要你的书收走，他把自己的书放到桌上
- 同一进程内的线程切换=你的舍友要用这张书桌，可以不把桌子上的书收走



#### 引入线程机制后，有什么变化？

![](E:\note\OS\进程\变化.jpg)



#### 线程的属性

![](E:\note\OS\进程\线程属性.jpg)



#### 线程的实现方式

- 用户级线程
- 内核级线程
- 组合方式



##### 用户级线程

用户级线程由应用程序通过线程库实现。
所有的**线程管理工作**都由**应用程序负责**（包括线程切换）
用户级线程中，**线程切换**可以在用户态下即可完成，**无需操作系统干预**。
在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。（用
户级线程对用户不透明，对操作系统透明）
可以这样理解，“用户级线程”就是“从用户视角看能看到的线程”

![](E:\note\OS\进程\用户级线程.jpg)



##### 内核级线程

内核级线程的**管理工作**由**操作系统内核完成**。线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。
可以这样理解，“内核级线程”就是“从操作系统内核视角看能看到的线程”

![](E:\note\OS\进程\内核级线程.jpg)



##### 组合线程

在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m个内核级线程上（ n >= m）

![](E:\note\OS\进程\组合线程.jpg)

> 重点重点重点：
> 操作系统只“看得见”内核级线程，因此**只有内核级线程才是处理机分配的单位**。
> 例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，也最多只能被分配到两个核，最多只能有两个用户线程并行执行。



#### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。

##### 多对一模型：

多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。
优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

![](E:\note\OS\进程\多对一.jpg)

##### 一对一模型：

一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核线程。
优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

![](E:\note\OS\进程\一对一.jpg)

##### 多对多模型：

n 用户及线程映射到m 个内核级线程（n >= m）。每个用户进程对应m 个内核级线程。
克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

![](E:\note\OS\进程\多对多.jpg)





## 二、处理机调度

### 1.调度的概念

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

#### 高级调度（作业调度）

按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。

高级调度是辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。



> 暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。

#### 中级调度（内存调度）

中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。



#### 低级调度（进程调度）

低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。
进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。



#### 三层调度的联系、对比

![](E:\note\OS\进程\对比.jpg)

![](E:\note\OS\进程\三级调度.jpg)

**联系**

作业调度从外存的后备队列中选择一批作业进入内存，为它们建立进程，这些进程被送入就绪队列，进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。当内存空间宽松时，通过中级调度选择具备运行条件的进程，将其唤醒。

作业调度为进程活动做准备，进程调度是进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间。



#### 补充知识：进程的挂起态与七状态模型

暂时调到外存等待的进程状态为挂起状态（挂起态，suspend）
挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态。

注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。
有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。

![](E:\note\OS\进程\七状态.jpg)



### 2.调度的时机、切换与过程

#### 进程调度（低级调度）的时机

![](E:\note\OS\进程\时机.jpg)



#### 进程调度的方式

![](E:\note\OS\进程\方式.jpg)



#### 进程的切换与过程

**狭义的进程调度**指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换）

**广义的进程调度**包含了选择一个进程和进程切换两个步骤。

**进程切换**是指一个进程让出处理机，由另一个进程占用处理机的过程。

进程切换的过程主要完成了：
1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复
（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）

注意：进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，
使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。



### 3.调度算法的评价指标

![](E:\note\OS\进程\指标.jpg)



### 4.几种调度算法

- 先来先服务（FCFS）
- 短作业优先（SJF）
- 高响应比优先（HRRN）
- 时间片轮转调度算法（RR）
- 优先级调度算法
- 多级反馈队列调度算法



#### 先来先服务（FCFS, FirstCome First Serve）

![](E:\note\OS\进程\先来先服务.jpg)

##### 一个🌰

例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

![](E:\note\OS\进程\例子.jpg)

先来先服务调度算法：按照到达的先后顺序调度，事实上就是等待时间越久的越优先得到服务。
因此，调度顺序为：P1->P2->P3->P4

![](E:\note\OS\进程\答案.jpg)

![](E:\note\OS\进程\答案2.jpg)

平均周转时间= (7+9+8+11)/4 = 8.75
平均带权周转时间= (1+2.25+8+2.75)/4 = 3.5
平均等待时间= (0+5+7+7)/4 = 4.75



#### 短作业优先（SJF, Shortest Job First）

![](E:\note\OS\进程\短作业.jpg)

##### 一个🌰：非抢占式SPF

例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式的短作业优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

![](E:\note\OS\进程\例子.jpg)

短作业/进程优先调度算法：每次调度时选择当前已到达且运行时间最短的作业/进程。
因此，调度顺序为：P1->P3->P2->P4

**解释：**

刚开始只有p1到达，所以执行p1，然后当p1执行完毕后，此时是时刻7，剩余三个进程均已到达，所以按照运行时间最短的，执行p3，

![](E:\note\OS\进程\答案3.jpg)

周转时间= 完成时间- 到达时间          P1=7-0=7；P3=8-4=4；P2=12-2=10；P4=16-5=11
带权周转时间= 周转时间/运行时间        P1=7/7=1；P3=4/1=4；P2=10/4=2.5；P4=11/4=2.75
等待时间= 周转时间– 运行时间          P1=7-7=0；P3=4-1=3；P2=10-4=6；P4=11-4=7

平均周转时间= (7+4+10+11)/4 = 8
平均带权周转时间= (1+4+2.5+2.75)/4 = 2.56
平均等待时间= (0+3+6+7)/4 = 4

对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低



#### 对FCFS和SJF两种算法的思考…

- FCFS 算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题
- SJF 算法是选择一个执行时间最短的作业为其服务。但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题
- 能不能设计一个算法，即考虑到各个作业的等待时间，也能兼顾运行时间呢？
  **高响应比优先算法**



#### 高响应比优先算法

![](E:\note\OS\进程\高响应比.jpg)

高响应比优先算法：非抢占式的调度算法，只有当前运行的进程主动放弃CPU时（正常/异常完成，或主动阻塞），才需要进行调度，调度时计算所有就绪进程的响应比，选响应比最高的进程上处理机。

响应比 = 等待时间+要求服务时间 / 要求服务时间



##### 一个🌰

例题：各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

![](E:\note\OS\进程\例子.jpg)

![](E:\note\OS\进程\答案4.jpg)

- **0时刻**：只有P1 到达就绪队列，P1上处理机

- **7时刻（P1主动放弃CPU）**：就绪队列中有P2 (响应比=(5+4)/4=2.25)、P3((3+1)/1=4)、P4((2+4)/4=1.5)，

- **8时刻（P3完成）**： P2(2.5)、P4(1.75)

- **12时刻（P2完成）**：就绪队列中只剩下P4



#### 时间片轮转调度算法（RR）

![](E:\note\OS\进程\时间片.jpg)

![](E:\note\OS\进程\时间片轮转.jpg)



#### 优先级调度算法

![](E:\note\OS\进程\优先级调度.jpg)

对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能**从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法**。

进程的优先级可以分为，静态优先级和动态优先级：

- 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
- 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是**随着时间的推移增加等待进程的优先级**。

该算法也有两种处理优先级高的方法，非抢占式和抢占式：

- 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
- 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

但是依然有缺点，可能会导致低优先级的进程永远不会运行。

![](E:\note\OS\进程\优先级1.jpg)

![](E:\note\OS\进程\优先级2.jpg)



#### 多级反馈队列（Multilevel Feedback Queue）调度算法

是「时间片轮转算法」和「最高优先级算法」的综合和发展。

- 「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
- 「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列

![](E:\note\OS\进程\多级反馈.jpg)





## 三、进程同步与互斥

### 1.什么是进程同步与互斥

进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。

操作系统要提供“进程同步机制”来解决异步问题

#### 临界资源

一个时间段内只允许一个进程使用的资源称为**临界资源**。许多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。

**对临界资源的访问，必须互斥地进行**。



#### 什么是进程互斥

互斥，亦称间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。



##### 遵循四个原则

1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；

2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；

3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；

4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。





### 2.进程互斥的软件实现方法

- 单标志法
- 双标志先检查
- 双标志后检查
- Peterson算法



#### 单标志法

![](E:\note\OS\进程\单标志法.jpg)

![](E:\note\OS\进程\单问题.jpg)



#### 双标志先检查法

![](E:\note\OS\进程\双标志先.jpg)



#### 双标志后检查法

![](E:\note\OS\进程\双标志后.jpg)



#### Perterson算法

![](E:\note\OS\进程\Peterson算法.jpg)



### 3.进程互斥的硬件实现方法

- 中断屏蔽方法
- TestAndSet(TS指令/TSL指令)
- Swap指令(XCHG指令)



#### 中断屏蔽方法

![](E:\note\OS\进程\中断屏蔽.jpg)



#### TestAndSet(TS指令/TSL指令)

![](E:\note\OS\进程\test.jpg)



#### Swap指令(XCHG指令)

在逻辑上等同于TSL指令

![](E:\note\OS\进程\swap.jpg)



### 4.信号量机制

进程互斥的四种软件实现方式（单标志法、双标志先检查、双标志后检查、Peterson算法）

进程互斥的三种硬件实现方式（中断屏蔽方法、TS/TSL指令、Swap/XCHG指令）

1.在双标志先检查法中，进入区的“检查”、“上锁”操作无法一气呵成，从而导致了两个进程有可能同时进入临界区的问题；

2.所有的解决方案都无法实现“让权等待”



**实现进程互斥、同步的更优秀的方法：信号量机制**

用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。



#### 信号量

信号量其实就是一个变量，可以用一个信号量来表示系统中某种资源的数量，比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。原语是由关中断/开中断指令实现的。软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

一对原语：wait(S)原语和signal(S)原语，可以**把原语理解为我们自己写的函数**，函数名分别为wait和signal，括号里的**信号量S其实就是函数调用时传入的一个参数**。wait、signal原语常简称为P、V操作（来自荷兰语proberen和verhogen）。因此，做题的时候常把wait(S)、signal(S)两个操作分别写为P(S)、V(S)



信号量机制分为：整型信号量，记录型信号量



#### 信号量机制-整型信号量

![](E:\note\OS\进程\整型.jpg)



#### 信号量机制-记录型信号量

![](E:\note\OS\进程\记录1.jpg)

![](E:\note\OS\进程\记录2.jpg)



### 5.用信号量机制实现进程互斥、同步、前驱关系

#### 信号量机制实现进程互斥

![](E:\note\OS\进程\实现互斥.jpg)



#### 信号量机制实现进程同步

进程同步：要让各并发进程按要求有序地推进。

比如，P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。

若P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果才能执行，那么我们就必须保证“代码4”一定是在“代码2”之后才会执行。这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。

```
P1(){
  代码1;
  代码2;
  代码3;
}
P2(){
  代码4;
  代码5;
  代码6;
}
```

![](E:\note\OS\进程\实现同步.jpg)



#### 信号量机制实现前驱关系

![](E:\note\OS\进程\实现前驱.jpg)



### 6.生产者消费者问题

#### 描述

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（注：这里的“产品”理解为某种数据）
生产者、消费者共享一个初始为空、大小为n的缓冲区。

- 只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。  缓冲区没满->生产者生产
- 只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。  缓冲区没空->消费者消费
- 缓冲区是临界资源，各进程必须互斥地访问。



#### 实现

设置三个信号量

- semaphore mutex = 1; //互斥信号量，实现对缓冲区的互斥访问
- semaphore empty = n; //同步信号量，表示空闲缓冲区的数量
- semaphore full = 0; //同步信号量，表示产品的数量，也即非空缓冲区的数量

![](E:\note\OS\进程\实现.jpg)

![](E:\note\OS\进程\思考.jpg)



### 7.哲学家就餐问题

#### 描述

![](E:\note\OS\进程\描述.jpg)



#### 实现

如果5个哲学家并发地拿起了自己左手边的筷子… 那么每位哲学家循环等待右边的人放下筷子（阻塞）。发生“死锁”

如何防止死锁的发生呢？

**方案一**：可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的

**方案二**：要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。

**最终解决方案**：**仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。**

```
semaphore chopstick[5]={1,1,1,1,1};
semaphore mutex = 1; //互斥地取筷子
Pi (){ //i号哲学家的进程
    while(1){
        P(mutex);
        P(chopstick[i]); //拿左
        P(chopstick[(i+1)%5]); //拿右
        V(mutex);
        吃饭…
        V(chopstick[i]); //放左
        V(chopstick[(i+1)%5]); //放右
        思考…
    }
}
```



### 8.读者-写者问题

#### 描述

![](E:\note\OS\进程\读写.jpg)



#### 实现

![](E:\note\OS\进程\解决.jpg)

##### 初版解决方案

```
semaphore rw=1; //用于实现对共享文件的互斥访问
int count = 0; //记录当前有几个读进程在访问文件
semaphore mutex = 1;//用于保证对count变量的互斥访问
```

```
writer (){
    while(1){
        P(rw); //写之前“加锁”
        写文件…
        V(rw); //写完了“解锁”
    }
}
reader (){
    while(1){
        P(mutex); //各读进程互斥访问count
        if(count==0) //由第一个读进程负责
        	P(rw); //读之前“加锁”
        count++; //访问文件的读进程数+1
        V(mutex);
        读文件…
        P(mutex); //各读进程互斥访问count
        count--; //访问文件的读进程数-1
        if(count==0) //由最后一个读进程负责
        V(rw); //读完了“解锁”
        V(mutex);
    }
}
```

为什么要对各个读进程加锁和解锁？

若两个读进程并发执行，则count=0时两个进程也许都能满足if条件，都会执行P(rw)，从而是第二个读进程阻塞的情况。

如何解决：竖线上述问题的**原因在于对count变量的检查和赋值无法一气呵成**，因此可以设置另一个互斥信号量来保证个读进程对count的访问是互斥的。



这种解决方案潜在的问题：

只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”，因此，这种算法中，读进程是优先的。



##### 终版解决方案

那既然有读者优先策略，自然也有写者优先策略：

- 只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；
- 如果有写者持续不断写入，则读者就处于饥饿；

![](E:\note\OS\进程\读写公平.jpg)





## 四、死锁

### 1.什么是死锁

在并发环境下，个进程因竞争资源而造成的一种**互相等待对方手里的资源，导致个进程都阻塞，都无法向前推进**的现象，就是“死锁”。发生死锁后若无外力干涉，这些进程都将无法向前推进。



### 2.死锁产生的必要条件

产生死锁必须同时满足一下四个条件，只要其中任一条件不成立，死锁就不会发生。

- **互斥条件**：只有对必须互斥使用的资源的争抢才会导致死锁（如哲学家的筷子、打印机设备）。像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的（因为进程不用阻塞等待这种资源）。

- **不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

- **请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。
- **循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求

> 注意！**发生死锁时一定有循环等待**，但是发生循环等待时未必死锁（循环等待是死锁的必要不充分条件）
>
> 如果同类资源数大于1，则即使有循环等待，也未必发生死锁。但如果系统中每类资源都只有一个，那循环等待就是死锁的充分必要条件了。



### 3.什么时候会发生死锁

1.对系统资源的竞争。各进程对不可剥夺的资源（如打印机）的竞争可能引起死锁，对可剥夺的资源（CPU）的竞争是不会引起死锁的。

2.进程推进顺序非法。请求和释放资源的顺序不当，也同样会导致死锁。例如，并发执行的进程P1、P2分别申请并占有了资源R1、R2，之后进程P1又紧接着申请资源R2，而进程P2又申请资源R1，两者会因为申请的资源被对方占有而阻塞，从而发生死锁。

3.信号量的使用不当也会造成死锁。如生产者-消费者问题中，如果实现互斥的P操作在实现同步的P操作之前，就有可能导致死锁。（可以把互斥信号量、同步信号量也看做是一种抽象的系统资源）



### 4.死锁的处理策略

1.预防死锁。破坏死锁产生的四个必要条件中的一个或几个。

2.避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）

3.死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。



### 5.死锁的处理策略——预防死锁

死锁的产生必须满足四个必要条件，只要其中一个或者几个条件不满足，死锁就不会发生。

- 破坏互斥条件
- 破坏不剥夺条件
- 破坏请求个保持条件
- 破坏循环等待条件



#### 破坏互斥条件

![](E:\note\OS\进程\破坏互斥.jpg)



#### 破坏不剥夺条件

**不剥夺条件**：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。破坏不剥夺条件：

- 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件。
- 方案二：当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级（比如：剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

该策略的缺点：

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般只适用于易保存和恢复状态的资源，如CPU。
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用方案一，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会导致进程饥饿。



#### 破坏请求和保持条件

**请求和保持条件**：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

可以**采用静态分配方法**，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不让它投入运行。一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

该策略实现起来简单，但也有明显的缺点：
有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低**。另外，该策略也**有可能导致某些进程饥饿**。



#### 破坏循环等待条件

**循环等待条件**：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

可采用**顺序资源分配法**。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完。

原理分析：一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象。



##### 一个🌰

假设系统中共有10个资源，编号为1, 2, …… 10

P1: 1号  3号

P2: 2号  4号

P3: 5号  7号

在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。因此，不可能出现所有进程都阻塞的死锁现象。



该策略的缺点：

1. 不方便增加新的设备，因为可能需要重新分配所有的编号；
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；
3. 必须按规定次序申请资源，用户编程麻烦。



### 6.死锁的处理策略——避免死锁

#### 什么是安全序列

所谓**安全序列**，就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是**安全状态**。当然，**安全序列可能有多个**。

如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了**不安全状态**。这就意味着之后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那**系统也有可能重新回到安全状态**，不过我们在分配资源之前总是要考虑到最坏的情况。

**如果系统处于安全状态，就一定不会发生死锁**。如果系统进入不安全状态，就可能发生死锁（**处于不安全状态未必就是发生了死锁，但发生死锁时一定是在不安全状态**）

因此可以**在资源分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。这也是“**银行家算法**”的核心思想。



#### 银行家算法

核心思想：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

![](E:\note\OS\进程\银行家算法.jpg)



### 7.死锁的处理策略——检测和解除

如果系统中既不采取预防死锁的措施，也不采取避免死锁的措施，系统就很可能发生死锁。在这种情况下，系统应当提供两个算法：
①死锁检测算法：用于检测系统状态，以确定系统中是否发生了死锁。
②死锁解除算法：当认定系统中已经发生了死锁，利用该算法可将系统从死锁状态中解脱出来。



#### 死锁的检测

![](E:\note\OS\进程\检测.jpg)

如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。

如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程…

如果按上述过程分析，最终能消除所有边，就称这个图是可完全简化的。此时一定没有发生死锁（相当于能找到一个安全序列）
如果最终**不能消除所有边**，那么此时就是**发生了死锁**

最终还连着边的那些进程就是处于死锁状态的进程。



#### 死锁的解除

一旦检测出死锁的发生，就应该立即解除死锁

补充：并不是系统中所有的进程都是死锁状态，用死锁检测算法化简资源分配图后，还连着边的那些进程就是死锁进程

解除死锁的主要方法有：

1. **资源剥夺法**。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。
2. **撤销进程法**（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来。
3. **进程回退法**。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统要记录进程的历史信息，设置还原点。
