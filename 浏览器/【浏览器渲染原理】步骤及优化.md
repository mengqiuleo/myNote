# 【浏览器渲染原理】步骤及优化

[TOC]





## 一、对浏览器内核的理解

浏览器内核主要分成两部分：

- **渲染引擎**的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。
- **JS 引擎**：解析和执行 javascript 来实现网页的动态效果。



最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。



## 二、浏览器的主要组成部分

- **⽤户界⾯** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。 
- **浏览器引擎** - 在⽤户界⾯和呈现引擎之间传送指令。 
- **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 
- **⽹络** - ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。 
- **⽤户界⾯后端** - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。 
- **JavaScript** **解释器**。⽤于解析和执⾏ JavaScript 代码。 
- **数据存储** - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。 



值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。



## 三、浏览器的渲染过程

> 解析: 浏览器读取的代码的过程，就是解析。
> 渲染: 渲染完毕之后，用户就能看见对应的东西



一个渲染引擎主要包括：HTML解释器，css解析器，JavaScript引擎，布局Layout模块，绘图模块

- HTML解析器 : 解析HTML文档的解析，主要作用是将HTML文本解析为DM树。
- CSS解析器: 它的作业是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施
- JavaScript引擎: 使用JavaScript代码可以修改网页的内容，也能修改css的信息，JavaScript引擎能够解释JavaScript代码，并通过DOM接口操作页面。
- 布局(Layout):在DOM创建之后,需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息。
- 绘图模块(paint)：使用图形库将布局计算后的各个网页的节点绘制层图像结构。



[点击这里👉](https://blog.csdn.net/weixin_52834435/article/details/123625348?spm=1001.2014.3001.5501)



大致过程如图所示：

![](E:\note\前端\笔记\浏览器\渲染原理\结构图.png)

**注意：**这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。



## 四、浏览器渲染优化

### ① 针对JavaScript：

JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：

（1）尽量将JavaScript文件放在body的最后

（2） body中间尽量不要写`<script>`标签

（3）`<script>`标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：

- **script** 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；
- **async** 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；

​		``<script async src="script.js"></script>``

- **defer** 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。



### ② 针对CSS：

使用CSS有三种方式：使用**link、@import、内联样式**，其中link和@import都是导入外部样式。它们之间的区别：

- **link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码
- **@import**：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)
- **style**：GUI直接渲染



外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。



所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。



### ③ 针对DOM树、CSSOM树：

可以通过以下几种方式来减少渲染的时间：

- HTML文件的代码层级尽量不要太深
- 使用语义化的标签，来避免不标准语义化的特殊处理
- 减少CSSD代码的层级，因为选择器是从左向右进行解析的



### ④ 减少回流与重绘：

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。



浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**



**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**



将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。



## 五、渲染过程中遇到 JS 文件如何处理？

JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。

- css的解析和JS的执行都互斥的，css解析的时候js停止执行，js执行的时候css停止解析。
- 无论css阻塞，或js阻塞，都不会阻塞浏览器加载外部资源(图片，视频，样式，脚本)。

因为浏览始终处于一种“先把请求发送出去”的工作模式，只要涉及到网络请求的内容，无论是：图片，样式，脚本，都会先发送请求去获取资源，至于**资源到本地之后什么时候用，由浏览器自己去协调**。



- 阻塞浏览器渲染
- 阻塞DOM解析
- 阻塞JS执行





## 六、什么是文档的预解析？

Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。



## 七、CSS 如何阻塞文档解析？

理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以**如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。**



## 八、如何优化关键渲染路径？

**什么是关键渲染路径**：

浏览器将HTML，CSS，JavaScript到首次渲染到屏幕上（首屏），这期间所经历的一系列步骤，叫做**关键渲染路径**（Critical Rendering Path）。

可见，通过优化关键渲染路径，我们可以显著缩短首次渲染页面的时间，从而得到一个更好的用户体验。



**什么是关键资源**：

**关键资源**指的是那些可以阻塞页面首次渲染的资源。例如JavaScript、CSS都是可以阻塞关键渲染路径的资源，这些资源就属于关键资源。图片不属于关键资源， 因为图片不会导致阻塞游览器渲染。



 如何优化关键渲染路径：

为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

 （1）关键资源的数量。

 （2）关键路径长度。

 （3）关键字节的数量。



**关键资源**是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。

**关键资源的长度**指的是获取所有关键资源时，在浏览器与服务器之间的往返次数。

同样，**关键路径长度**受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。

要减少**字节数**，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。



优化关键渲染路径的常规步骤如下：

 （1）对关键路径进行分析和特性描述：资源数、字节数、长度。

 （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。

 （3）优化关键字节数以缩短下载时间（往返次数）。

 （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度





## 九、什么情况会阻塞渲染？

首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。



当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。



## 十、回流与重绘

### ① 回流与重绘的概念及触发条件

#### （1）回流（重排）

当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为**回流**。



下面这些操作会导致回流：

- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素



在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：

- 全局范围：从根节点开始，对整个渲染树进行重新布局
- 局部范围：对渲染树的某部分或者一个渲染对象进行重新布局



#### （2）重绘

当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是**重绘**。



下面这些操作会导致回流：

- color、background 相关属性：background-color、background-image 等
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow

注意： **当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。**



### ② 如何避免回流与重绘？

**减少回流与重绘的措施：**

- 操作DOM时，尽量在低层级的DOM节点进行操作
- 不要使用`table`布局， 一个小的改动可能会使整个`table`进行重新布局
- 使用CSS的表达式
- 不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。
- 使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素
- 避免频繁操作DOM，可以创建一个文档片段`documentFragment`，在它上面应用所有DOM操作，最后再把它添加到文档中
- 将元素先设置`display: none`，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
- 将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于**浏览器的渲染队列机制**。



浏览器针对页面的回流与重绘，进行了自身的优化——**渲染队列**



**浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。**



上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。



### ③ 如何优化动画？

对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的`position`属性设置为`absolute`或者`fixed`，将动画脱离文档流，这样他的回流就不会影响到页面了。



## 十一、style样式的渲染

**style标签中的样式由html解析器进行解析**

style 标签里的样式是异步解析的，容易产生“闪屏”现象，浏览器加载资源是异步的，边加载边渲染





1、style标签不会阻止DOM的解析,但是会阻止页面的渲染

2、遇到耗时任务，style标签内容过多，再开启一个html解析器进行解析。

Tips: style中的样式不解析完毕，页面不会渲染。



style：内联

一进页面，就看见最初的样子，所有的加载过程都可以看见（过程都看出来）



## 十二、link引入

**link**：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码



1、遇到link，使用css解析器解析异步解析，接着解析下面的html。

2、等待图片和样式都加载完毕，计算样式，绘制页面。只有css解析完成工作才会绘制页面。

3、遇到link，使用css解析器解析异步解析，接着解析下面的html。

通过link引入，样式解析，计算都会造成阻塞。



**总结**

1、link进来的样式，由css解析器去解析，并且是同步解析的。

2、css解析器会阻塞页面的渲染。(link引入的外部样式会阻塞页面渲染)，不会阻塞DOM解析

3、推荐使用link引入样式。

**link：外链**

**一进页面先空白，因为这个时候在请求资源、解析，等着 Stylesheet 解析完了，统一渲染，只看见最终结果**

**所以我们一般用 link 外链，只向用户显示最终结果**